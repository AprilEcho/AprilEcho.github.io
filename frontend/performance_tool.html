<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Performance（工具&amp;api） | 新宿猫的博客小站</title>
    <meta name="generator" content="VuePress 1.5.4">
    <link rel="icon" href="/assets/icon/favicon.ico">
    <meta name="description" content="遇见即是上上签">
    <link rel="preload" href="/assets/css/0.styles.007b4830.css" as="style"><link rel="preload" href="/assets/js/app.654767d1.js" as="script"><link rel="preload" href="/assets/js/2.b710c5fc.js" as="script"><link rel="preload" href="/assets/js/5.8b669e08.js" as="script"><link rel="preload" href="/assets/js/19.c440fbe3.js" as="script"><link rel="preload" href="/assets/js/4.ad11ada8.js" as="script"><link rel="preload" href="/assets/js/6.12f579ad.js" as="script"><link rel="prefetch" href="/assets/js/10.8bee6a7c.js"><link rel="prefetch" href="/assets/js/11.0d4a067e.js"><link rel="prefetch" href="/assets/js/12.2190e8b9.js"><link rel="prefetch" href="/assets/js/13.3fb3d034.js"><link rel="prefetch" href="/assets/js/14.14f24357.js"><link rel="prefetch" href="/assets/js/15.8a6c496e.js"><link rel="prefetch" href="/assets/js/16.59c21fa7.js"><link rel="prefetch" href="/assets/js/17.7bad16b3.js"><link rel="prefetch" href="/assets/js/18.0ba8074b.js"><link rel="prefetch" href="/assets/js/20.c595bfcb.js"><link rel="prefetch" href="/assets/js/21.b8c83dce.js"><link rel="prefetch" href="/assets/js/22.1a12fd3b.js"><link rel="prefetch" href="/assets/js/23.e5427cca.js"><link rel="prefetch" href="/assets/js/24.c96ab9ac.js"><link rel="prefetch" href="/assets/js/25.60978acf.js"><link rel="prefetch" href="/assets/js/26.69ee2986.js"><link rel="prefetch" href="/assets/js/27.ac23803b.js"><link rel="prefetch" href="/assets/js/28.11020d82.js"><link rel="prefetch" href="/assets/js/29.210a3457.js"><link rel="prefetch" href="/assets/js/3.3dbd19d0.js"><link rel="prefetch" href="/assets/js/30.0365ef42.js"><link rel="prefetch" href="/assets/js/31.6e016901.js"><link rel="prefetch" href="/assets/js/32.a982afa7.js"><link rel="prefetch" href="/assets/js/33.5f2dd0dd.js"><link rel="prefetch" href="/assets/js/34.ba60f296.js"><link rel="prefetch" href="/assets/js/35.53bf1faf.js"><link rel="prefetch" href="/assets/js/7.af994d9a.js"><link rel="prefetch" href="/assets/js/8.e7984b57.js"><link rel="prefetch" href="/assets/js/9.1481c837.js">
    <link rel="stylesheet" href="/assets/css/0.styles.007b4830.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-273099e5><div class="blog-header" data-v-49a24226 data-v-273099e5><div class="tool-bar" data-v-49a24226><div class="toggle" data-v-49a24226><button class="show-list" data-v-49a24226><i aria-hidden="true" class="fa fa-bars" data-v-49a24226></i></button></div> <div class="tool-bar-1" data-v-49a24226><div class="navigation-bar" data-v-49a24226><div class="navigation-bar-item"><div class="bar-item"><a href="/" class="router-link-active"><button type="button">首页</button></a></div></div><div class="navigation-bar-item"><div class="bar-item"><a href="/daily-question/"><button type="button">每日一题</button></a></div></div><div class="navigation-bar-item"><div class="bar-item"><a href="/frontend/" class="router-link-active"><button type="button">前端笔记</button></a></div></div><div class="navigation-bar-item"><div class="bar-item"><a href="/categories/"><button type="button">分类</button></a></div></div><div class="navigation-bar-item"><div class="bar-item"><a href="/tags/"><button type="button">标签</button></a></div></div><div class="navigation-bar-item"><div class="bar-item"><a href="/essay"><button type="button">随记</button></a></div></div><div class="navigation-bar-item"><div class="bar-item"><a href="/about"><button type="button">关于我</button></a></div></div><div class="navigation-bar-item"><div class="bar-list">
    工具箱   <i aria-hidden="true" class="fa fa-caret-down"></i> <div class="bar-item-list"><div class="bar-item"><a href="http://zhongguose.com/" target="_blank"><button type="button">
            中国色
            <i aria-hidden="true" class="fa fa-external-link"></i></button></a></div><div class="bar-item"><a href="https://tinypng.com/" target="_blank"><button type="button">
            图片压缩
            <i aria-hidden="true" class="fa fa-external-link"></i></button></a></div><div class="bar-item"><a href="https://www.iconfont.cn/home/index" target="_blank"><button type="button">
            矢量图标
            <i aria-hidden="true" class="fa fa-external-link"></i></button></a></div><div class="bar-item"><a href="https://animista.net/" target="_blank"><button type="button">
            动画库
            <i aria-hidden="true" class="fa fa-external-link"></i></button></a></div></div></div></div></div></div> <div class="search" data-v-49a24226><div class="search-box" data-v-49a24226><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div> <div class="tool-bar-2" data-v-49a24226></div></div></div> <div class="list-container hide" data-v-67fbb87c data-v-273099e5></div> <div class="blog-sidebar hide" data-v-229076d0 data-v-273099e5><div class="sidebar-header" data-v-229076d0><div class="logo-box" data-v-229076d0><img src="/assets/img/logo.jpg" alt class="header-logo" data-v-229076d0></div> <p class="header-title" data-v-229076d0>新宿猫的博客小站</p> <p class="header-description" data-v-229076d0>遇见即是上上签</p></div> <div class="sidebar-subnav" data-v-229076d0><a href="/page/1" class="subnav-item" data-v-229076d0><span class="subnav-item__count" data-v-229076d0>18</span> <span class="subnav-item__name" data-v-229076d0>Archives</span></a><a href="/categories" class="subnav-item" data-v-229076d0><span class="subnav-item__count" data-v-229076d0>5</span> <span class="subnav-item__name" data-v-229076d0>Categories</span></a><a href="/tags" class="subnav-item" data-v-229076d0><span class="subnav-item__count" data-v-229076d0>15</span> <span class="subnav-item__name" data-v-229076d0>Tags</span></a></div> <div class="sidebar-nav" data-v-229076d0><a href="/" class="nav-item router-link-active" data-v-229076d0>
            首页
        </a><a href="/daily-question/" class="nav-item" data-v-229076d0>
            每日一题
        </a><a href="/frontend/" class="nav-item router-link-active" data-v-229076d0>
            前端笔记
        </a><a href="/categories/" class="nav-item" data-v-229076d0>
            分类
        </a><a href="/tags/" class="nav-item" data-v-229076d0>
            标签
        </a><a href="/essay" class="nav-item" data-v-229076d0>
            随记
        </a><a href="/about" class="nav-item" data-v-229076d0>
            关于我
        </a></div></div> <div class="theme-container__inner" data-v-273099e5><section class="main-container" data-v-273099e5><div class="article" data-v-03440d80 data-v-273099e5><div class="article-detail" data-v-03440d80><header class="post-header" data-v-03440d80><div class="post-title" data-v-03440d80><h1 data-v-03440d80>Performance（工具&amp;api）</h1></div> <div class="post-meta" data-v-03440d80><div class="post-time" data-v-03440d80><i aria-hidden="true" class="fa fa-calendar" data-v-03440d80></i> <time data-v-03440d80>2023-6-26</time></div> <div class="post-count" data-v-03440d80><i aria-hidden="true" class="fa fa-file-word-o" data-v-03440d80></i> <span data-v-03440d80>0</span> <span data-v-03440d80> - </span> <i aria-hidden="true" class="fa fa-clock-o" data-v-03440d80></i> <span data-v-03440d80>0m</span></div> <div class="article-footer" data-v-2f7bef74 data-v-03440d80><div class="article-category" data-v-2f7bef74><div class="article-category-custom" data-v-2f7bef74><span data-v-2f7bef74><a href="/categories/前端笔记" data-v-2f7bef74><i aria-hidden="true" class="fa fa-folder-o" data-v-2f7bef74></i>
                    前端笔记
                </a></span></div></div> <div class="article-tags" data-v-2f7bef74><div class="article-tag black" data-v-2f7bef74><a href class="tag-name" data-v-2f7bef74><i aria-hidden="true" class="fa fa-tag" data-v-2f7bef74></i> <span data-v-2f7bef74>性能优化</span></a></div></div></div></div></header> <div class="article-content" data-v-03440d80><div class="content__default" data-v-03440d80><h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p><code>Performance</code>  一个在前端开发领域中，无法被忽视的存在，如果我们的开发是一个满足需求就可以的产品，那么可能就用不到它；但是如果我们想对我们的这个产品，做一个极致的优化，那么  <code>Performance</code>  是一个很好的选择，也是一个不容忽视的选择。</p> <h2 id="performance-工具-和-api-的优缺点"><a href="#performance-工具-和-api-的优缺点" class="header-anchor">#</a> Performance 工具 和 api 的优缺点</h2> <h3 id="performance-工具-优点"><a href="#performance-工具-优点" class="header-anchor">#</a> <code>Performance 工具</code>  优点：</h3> <ul><li>可视化图形界面</li> <li>每毫秒做的事情</li> <li>文件的执行加载的顺序</li> <li>每毫秒界面展示的效果</li> <li>每个方法执行的顺序和时间（由下至上）</li> <li>倒置的事件火焰图（由下至上）</li> <li>数据总结</li></ul> <h3 id="performance-工具-缺点"><a href="#performance-工具-缺点" class="header-anchor">#</a> <code>Performance 工具</code>  缺点：</h3> <ul><li>无法查看某一个区间之内的运行时间</li> <li>无法查看  <code>js</code>  堆的大小使用情况及限制</li> <li>无法查看页面是刷新还是加载，重定向次数</li> <li>无法查看什么时间开始做的性能测试</li> <li>可以在资源缓存已满的时候进行回调处理</li> <li>设置浏览器应在其性能条目缓冲区中保存的最大性能条目对象数</li></ul> <h3 id="performance-api-优点"><a href="#performance-api-优点" class="header-anchor">#</a> <code>Performance api</code>  优点：</h3> <ul><li>完全弥补了  <code>Performance 工具</code>  的缺点，还可以让我们通过数据的方式去知道具体的时间</li></ul> <h3 id="performance-api-缺点"><a href="#performance-api-缺点" class="header-anchor">#</a> <code>Performance api</code>  缺点：</h3> <ul><li>无法像  <code>Performance 工具</code>  那样图形化的去查看数据信息</li></ul> <p>大致的介绍了一下工具和 api 的优缺点，其实很明显的可以看出来，它们是相辅相成的，其实在一般的工具当中，我们会使用其中的某一个去进行性能的优化，但是对于一个想要进行真正的，彻底性的性能优化，还是需要两者之间的配合，去进行更高效、更系统、更全面的优化。</p> <h2 id="performance-工具"><a href="#performance-工具" class="header-anchor">#</a> Performance 工具</h2> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cf1f82f767344d6836a48f15579a6cf~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>这就是  <code>Performance 工具</code>  的界面。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35340953dede41a6aa7bebf2be7445ec~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <ul><li>上下箭头，就是用来上传和下载每一次性能检测报告的；</li> <li><code>no recordings</code>  就是每一次的检测报告，可以根据每一次的检测报告，去进行性能优化的对比；</li> <li><code>Screenshots</code>  是用来查看在每个时间段界面的变化；</li> <li><code>Memory</code>  存储调用栈的大小，在不同时间段的不同大小；</li></ul> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa35f91690ba43a7a09bf92750ed42f9~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <ul><li><code>Disable Javascript samples</code>  禁用  <code>javascript</code>  调用栈，在后面讲解  <code>Main</code>  部分进行详解；</li> <li><code>Enable advanced paint instrumentation (slow)</code>  记录渲染事件的细节；</li> <li><code>Network</code>  用来修改检测在不同的网络环境下，界面的渲染；</li> <li><code>CPU</code>  用来查看电脑的性能问题；</li></ul> <p>到这里呢，简单的介绍了一下上面几个按钮真正的意义，下面结合可视化的图表在配上面这些按钮进行性能的检测：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc2e1c78a6e14dcfae361551597745a2~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>这个性能检测是对掘金网站 --&gt; 我的主页做的性能优化检测截图</p> <h3 id="第一部分-概览"><a href="#第一部分-概览" class="header-anchor">#</a> 第一部分：概览</h3> <p>这里最主要是整体的界面渲染的时候，每个时间段执行的事件顺序，通过上图，我们就能知道我们每个时间段（精确到毫秒）都做了什么，当鼠标放上去的时候，我们还可以大图的形式去查看我们每个时间段界面的渲染情况：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c448442f92804119af65e263980d945b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>当在这里通过点击滑动到某一位置松开的时候，可以查看某一个区间直接的一个渲染情况</p> <h3 id="第二部分-network"><a href="#第二部分-network" class="header-anchor">#</a> 第二部分：Network</h3> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1400e5f577a473ea6117ec45a8555a6~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p><code>Network</code>  这里我们可以看出来，我们资源加载的一个顺序情况，什么时间加载了什么资源，通过这里，我们更直观的可以知道，<strong>资源是并行加载的</strong></p> <h3 id="第三部分-frames"><a href="#第三部分-frames" class="header-anchor">#</a> 第三部分：Frames</h3> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54ba13ab59ee42b0b625853a9a72ee94~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p><code>Frames</code>  这里，其实就是查看我们在什么时间，界面发生了改变，它和第一部分的区别就是在界面没有改变的时候，它是不做记录的，但是概览部分是会做记录的</p> <h3 id="第四部分-interactions"><a href="#第四部分-interactions" class="header-anchor">#</a> 第四部分： Interactions</h3> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e027945e3e87466c872fc59c9e17f3a7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>在我看过的文章里，很少看到会有这部分，是因为在不适用一些交互动作的时候，是不会有这部分的功能的，从这里我们看到了掘金使用了一些动画的动作</p> <h3 id="第五部分-timings"><a href="#第五部分-timings" class="header-anchor">#</a> 第五部分：Timings</h3> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c8286aa37044b21be12a190cf388d4d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>这张图不是掘金官网的，因为在项目打包后，就没有对应的事件调用，所以在线上经过打包的网站，是看不到这部分的</p> <h3 id="第六部分-main"><a href="#第六部分-main" class="header-anchor">#</a> 第六部分：Main</h3> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b6b36a8f87e49728f3b691a6fb43e3a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>这里就是  <code>Performance 工具</code>  当中比较核心的一部分，俗称  <strong>火焰图</strong> , 这里是一个由下而上的事件执行图，你可以简单的理解成上面这是一个汇总</p> <h3 id="第七部分-raster"><a href="#第七部分-raster" class="header-anchor">#</a> 第七部分：Raster</h3> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6e4f73c35464068bc4cc50e3359ea8b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>通过这里，我们知道掘金官网，在前端部分一共使用了几条线程</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>复制代码
这里有一个知识点，这里是指浏览器渲染的线程，而不是js的线程，特此声明一下，怕被有的同学拿js单线程来喷我😹
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="第八部分-gpu"><a href="#第八部分-gpu" class="header-anchor">#</a> 第八部分： GPU</h3> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1144a4ea85284773aeb54d798607ee1e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>这里我们可以很清楚的看出来，网站在什么时间有  <code>GPU</code>  加速</p> <h3 id="第九部分-taskschedulerforegroundblockingworker"><a href="#第九部分-taskschedulerforegroundblockingworker" class="header-anchor">#</a> 第九部分：taskSchedulerForegroundBlockingWorker</h3> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c72339e1fa144badb556bf4dfc3bd05e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>任务计划程序前台阻止工作程序，这里我用的很少，也是第一次见，等的我明确一下这里是做什么的，在进行更新，如果有知道的朋友，也可以评论告诉我，我及时进行改进</p> <h3 id="第十部分-memory"><a href="#第十部分-memory" class="header-anchor">#</a> 第十部分：Memory</h3> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1032b308e5924b1099f6ba3d0802fa39~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>上面有提到  <code>Memory</code>  选项，在勾选后，就会显示该事件折线图，通过该图，可以看出我们在不同的时间段，不同事件的执行情况</p> <h3 id="第十一部分-性能检测详情"><a href="#第十一部分-性能检测详情" class="header-anchor">#</a> 第十一部分：性能检测详情</h3> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0adcd676ad834206a0c4b1121f2e45fc~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>上面有 4 个标签：<code>Summary（性能摘要）</code> 、 <code>Bottom-Up（事件列表，由下至上，对应 Main 火焰图）</code> 、 <code>Call Tree（每个事件的子项信息）</code> 、 <code>Event log（事件日志）</code></p> <p>接下来，我们依次详解</p> <h4 id="summary-性能摘要"><a href="#summary-性能摘要" class="header-anchor">#</a> Summary（性能摘要）</h4> <p>其实我们一看就明白，它是一个用来统计在我们检测性能的时间范围内，都做了哪些事情：</p> <ul><li><code>Loading</code> ：加载时间</li> <li><code>Scripting</code> ：js 计算时间</li> <li><code>Rendering</code> ：渲染时间</li> <li><code>Painting</code> ：绘制时间</li> <li><code>Other</code> ：其他时间</li> <li><code>Idle</code> ：浏览器闲置时间</li></ul> <h4 id="bottom-up-事件列表"><a href="#bottom-up-事件列表" class="header-anchor">#</a> Bottom-Up（事件列表）</h4> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd6dd0743f004dd7b372d84777c6988e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>这里和  <code>Main</code>  里面看见的，其实是一个对应着的关系，从这里，我们可以看见所有的事件列表，还有每个事件的  <code>Self Time（自己调用的时间）</code> 、 <code>Total Time（总调用时间，包括子项调用时间）</code> 、 <code>Activity（行为，包括调用该事件的位置）</code></p> <h4 id="call-tree-事件子项信息"><a href="#call-tree-事件子项信息" class="header-anchor">#</a> Call Tree（事件子项信息）</h4> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11c14465e31142cabc3d9161213ebbf4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>其实这里和  <code>Bottom-Up</code>  部分是一样的，就不做太多的说明了，大家看一下就知道了</p> <h4 id="event-log-事件日志"><a href="#event-log-事件日志" class="header-anchor">#</a> Event Log（事件日志）</h4> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d550949f6294382897ff1c29b5e09bc~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>这里比前面的  <code>Bottom-Up</code>  和  <code>Call Tree</code>  相比，多了一个  <code>Start Time</code>  属性，这个属性其实就是开始的时间，从什么时间开始执行的什么事件</p> <p>到这里，有关  <code>Performance 工具</code>  的介绍，就到了这里了，如果有什么解释不清楚的，或者有问题的地方，还请大家评论指出，我做及时的更正</p> <p>下面，给大家介绍  <code>Performance Api</code></p> <h2 id="performance-api"><a href="#performance-api" class="header-anchor">#</a> Performance API</h2> <p><code>Performance</code>  用来获取当前页面的性能信息，它和  <code>Performance 工具</code>  的区别在上面我们已经写出来了，就不在这里啰嗦了</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>复制代码
注意：除了以下指出的情况外，该接口及其成员在 Web Worker 中可用。
此外，还需注意，performance 的创建和衡量都是同一环境下的。
即，如果你在主线程（或者其他 worker）中创建了一个 performance，那么它在另外的 worker 线程中是不可用的；反之亦然。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>接下来，我们先介绍一下  <code>Performance API</code>  的属性：</p> <hr> <h3 id="performance-navigation-操作相关"><a href="#performance-navigation-操作相关" class="header-anchor">#</a> <code>Performance.navigation（操作相关）</code></h3> <p>该属性是一个对象，有两个属性值，分别是  <code>redirectCount（重定向次数）</code> 、 <code>type（操作的类型）</code>：</p> <h4 id="redirectcount"><a href="#redirectcount" class="header-anchor">#</a> <code>redirectCount</code></h4> <p>该属性值为几，就说明了当前页面重定向了多少次；</p> <h4 id="type"><a href="#type" class="header-anchor">#</a> <code>type</code></h4> <p><code>type(0)</code>：当前页面是通过点击链接，书签和表单提交，或者脚本操作，或者在 url 中直接输入地址;</p> <p><code>type(1)</code>：点击刷新页面按钮或者通过 Location.reload()方法显示的页面；</p> <p><code>type(2)</code>：页面通过历史记录和前进后退访问时；</p> <p><code>type(255)</code>：任何其他方式</p> <hr> <h3 id="performance-timing-延迟相关"><a href="#performance-timing-延迟相关" class="header-anchor">#</a> <code>Performance.timing（延迟相关）</code></h3> <p>当前页面中与时间相关的信息：</p> <h4 id="navigationstart"><a href="#navigationstart" class="header-anchor">#</a> <code>navigationStart</code></h4> <p>从同一个浏览器的上一个页面卸载  <code>unload</code>  结束时的时间戳（精确到毫秒）</p> <h4 id="unloadeventstart"><a href="#unloadeventstart" class="header-anchor">#</a> <code>unloadEventStart</code></h4> <p><code>unload</code>  事件执行时的时间戳。如果没有上一个页面，或者如果先前的页面或所需的重定向之一不是同一个来源, 这个值会返回 0</p> <h4 id="unloadeventend"><a href="#unloadeventend" class="header-anchor">#</a> <code>unloadEventEnd</code></h4> <p><code>unload</code>  事件执行完的时间戳。如果没有上一个页面，或者如果先前的页面或所需的重定向之一不是同一个来源, 这个值会返回 0</p> <h4 id="redirectstart"><a href="#redirectstart" class="header-anchor">#</a> <code>redirectStart</code></h4> <p>第一个 HTTP 重定向开始时得时间戳。如果没有上一个页面，或者如果先前的页面或所需的重定向之一不是同一个来源, 这个值会返回 0</p> <h4 id="redirectend"><a href="#redirectend" class="header-anchor">#</a> <code>redirectEnd</code></h4> <p>最后一个 HTTP 重定向完成时（也就是说是 HTTP 响应的最后一个字节直接被收到的时间）的时间戳</p> <h4 id="fetchstart"><a href="#fetchstart" class="header-anchor">#</a> <code>fetchStart</code></h4> <p>表征了浏览器准备好使用 HTTP 请求来获取(fetch)文档的时间戳。这个时间点会在检查任何应用缓存之前</p> <h4 id="domainlookupstart"><a href="#domainlookupstart" class="header-anchor">#</a> <code>domainLookupStart</code></h4> <p>表征了域名查询开始的时间戳。如果使用了持续连接，或者这个信息存储到了缓存或者本地资源上，这个值将和  <code>PerformanceTiming.fetchStart</code>  一致</p> <h4 id="domainlookupend"><a href="#domainlookupend" class="header-anchor">#</a> <code>domainLookupEnd</code></h4> <p>表征了域名查询结束的时间戳。如果使用了持续连接，或者这个信息存储到了缓存或者本地资源上，这个值将和  <code>PerformanceTiming.fetchStart</code>  一致</p> <h4 id="connectstart"><a href="#connectstart" class="header-anchor">#</a> <code>connectStart</code></h4> <p>返回 HTTP 请求开始向服务器发送时的时间戳。如果使用持久连接，则返回值等同于  <code>fetchStart</code>  属性的值</p> <h4 id="connectend"><a href="#connectend" class="header-anchor">#</a> <code>connectEnd</code></h4> <p>返回浏览器与服务器之间的连接建立时的时间戳。如果建立的是持久连接，则返回值等同于  <code>fetchStart</code>  属性的值。连接建立指的是所有握手和认证过程全部结束</p> <h4 id="secureconnectionstart"><a href="#secureconnectionstart" class="header-anchor">#</a> <code>secureConnectionStart</code></h4> <p>返回浏览器与服务器开始安全链接的握手时的时间戳。如果当前网页不要求安全连接，则返回 0</p> <h4 id="requeststart"><a href="#requeststart" class="header-anchor">#</a> <code>requestStart</code></h4> <p>返回浏览器向服务器发出 HTTP 请求时（或开始读取本地缓存时）的时间戳</p> <h4 id="responsestart"><a href="#responsestart" class="header-anchor">#</a> <code>responseStart</code></h4> <p>返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的时间戳。如果传输层在开始请求之后失败并且连接被重开，该属性将会被数制成新的请求的相对应的发起时间</p> <h4 id="responseend"><a href="#responseend" class="header-anchor">#</a> <code>responseEnd</code></h4> <p>返回浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时（如果在此之前 HTTP 连接已经关闭，则返回关闭时）的时间戳</p> <h4 id="domloading"><a href="#domloading" class="header-anchor">#</a> <code>domLoading</code></h4> <p>返回当前网页 DOM 结构开始解析时（即  <code>Document.readyState</code>  属性变为  <code>loading</code> 、相应的  <code>readystatechange</code>  事件触发时）的时间戳</p> <h4 id="dominteractive"><a href="#dominteractive" class="header-anchor">#</a> <code>domInteractive</code></h4> <p>返回当前网页 DOM 结构结束解析、开始加载内嵌资源时（即  <code>Document.readyState</code>  属性变为  <code>interactive</code> 、相应的  <code>readystatechange</code>  事件触发时）的时间戳</p> <h4 id="domcontentloadedeventstart"><a href="#domcontentloadedeventstart" class="header-anchor">#</a> <code>domContentLoadedEventStart</code></h4> <p>返回当解析器发送  <code>DOMContentLoaded</code>  事件，即所有需要被执行的脚本已经被解析时的时间戳</p> <h4 id="domcontentloadedeventend"><a href="#domcontentloadedeventend" class="header-anchor">#</a> <code>domContentLoadedEventEnd</code></h4> <p>返回当所有需要立即执行的脚本已经被执行（不论执行顺序）时的时间戳</p> <h4 id="domcomplete"><a href="#domcomplete" class="header-anchor">#</a> <code>domComplete</code></h4> <p>返回当前文档解析完成，即  <code>Document.readyState</code>  变为  <code>complete</code>  且相对应的  <code>readystatechange</code>  被触发时的时间戳</p> <h4 id="loadeventstart"><a href="#loadeventstart" class="header-anchor">#</a> <code>loadEventStart</code></h4> <p>返回该页面下，<code>load</code>  事件被发送时的时间戳。如果这个事件还未被发送，它的值将会是 0</p> <h4 id="loadeventend"><a href="#loadeventend" class="header-anchor">#</a> <code>loadEventEnd</code></h4> <p>返回当  <code>load</code>  事件结束，即加载事件完成时的时间戳。如果这个事件还未被发送，或者尚未完成，它的值将会是 0</p> <hr> <h3 id="performance-memory-js堆相关"><a href="#performance-memory-js堆相关" class="header-anchor">#</a> <code>Performance.memory（js堆相关）</code></h3> <p>js 堆有关的信息：</p> <h4 id="jsheapsizelimit"><a href="#jsheapsizelimit" class="header-anchor">#</a> <code>jsHeapSizeLimit</code></h4> <p>js 堆大小限制</p> <h4 id="totaljsheapsize"><a href="#totaljsheapsize" class="header-anchor">#</a> <code>totalJSHeapSize</code></h4> <p>js 堆总大小</p> <h4 id="usedjsheapsize"><a href="#usedjsheapsize" class="header-anchor">#</a> <code>usedJSHeapSize</code></h4> <p>使用了 js 堆的大小</p> <hr> <h3 id="performance-timeorigin-性能检测开始时间"><a href="#performance-timeorigin-性能检测开始时间" class="header-anchor">#</a> <code>Performance.timeOrigin（性能检测开始时间）</code></h3> <p>这个属性返回的是性能测量开始时的时间的高精度时间戳，<code>number</code>  类型</p> <p><code>Performance</code>  还有一个事件：</p> <hr> <h3 id="performance-onresourcetimingbufferfull-性能缓存区已满时回调"><a href="#performance-onresourcetimingbufferfull-性能缓存区已满时回调" class="header-anchor">#</a> <code>Performance.onresourcetimingbufferfull（性能缓存区已满时回调）</code></h3> <p>这个事件当浏览器的资源时间性能缓冲区已满时会触发</p> <p>下面介绍一下  <code>Performance</code>  对象的方法：</p> <hr> <h3 id="performance-clearmarks"><a href="#performance-clearmarks" class="header-anchor">#</a> <code>Performance.clearMarks()</code></h3> <p>将给定的 mark 从浏览器的性能输入缓冲区中移除</p> <hr> <h3 id="performance-clearmeasures"><a href="#performance-clearmeasures" class="header-anchor">#</a> <code>Performance.clearMeasures()</code></h3> <p>将给定的 measure 从浏览器的性能输入缓冲区中</p> <hr> <h3 id="performance-clearresourcetimings"><a href="#performance-clearresourcetimings" class="header-anchor">#</a> <code>Performance.clearResourceTimings()</code></h3> <p>从浏览器的性能数据缓冲区中移除所有  <code>entryType</code>  是  <code>resource</code>  的  <code>performance entries</code></p> <hr> <h3 id="performance-getentries-performanceentryfilteroptions"><a href="#performance-getentries-performanceentryfilteroptions" class="header-anchor">#</a> <code>Performance.getEntries(PerformanceEntryFilterOptions)</code></h3> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a286aadfa94141f7b3cd3c8a62137ef5~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <h4 id="performanceentryfilteroptions-参数"><a href="#performanceentryfilteroptions-参数" class="header-anchor">#</a> <code>PerformanceEntryFilterOptions</code>  参数</h4> <p>可选参数，该参数是一个对象，可接受三个属性：</p> <ul><li><code>name</code>： <code>performance entry</code>  的名字</li> <li><code>entryType</code>：<code>entry</code>  类型. 合法的  <code>entry</code>  类型可以从  <code>PerformanceEntry.entryType</code>  方法获取</li> <li><code>initiatorType</code>：初始化资源的类型，例如：<code>xmlhttprequest</code> 、 <code>other</code> 、 <code>script</code></li></ul> <h4 id="performance-getentries-返回值"><a href="#performance-getentries-返回值" class="header-anchor">#</a> <code>Performance.getEntries</code>  返回值</h4> <p><code>Performance.getEntries(PerformanceEntryFilterOptions)</code>  返回值数组成员按  <code>PerformanceEntry.startTime</code>  时间顺序排列</p> <p>如果没有符合  <code>filter</code>  条件的对象，那么返回空数组. 如果不带任何参数，返回全部  <code>entries</code></p> <p>由于返回值是一个数组，所以我们接下来讲解一下每一个数组项的每一个属性的意思：</p> <ul><li><code>connectEnd</code>：连接结束时间</li> <li><code>connectStart</code>：连接开始时间</li> <li><code>decodedBodySize</code>：解码的主体大小</li> <li><code>domComplete</code>：<code>dom</code>  渲染完成时间</li> <li><code>domContentLoadedEventEnd</code>：<code>dom</code>  内容加载事件结束时间</li> <li><code>domContentLoadedEventStart</code>：<code>dom</code>  内容加载事件开始时间</li> <li><code>domInteractive</code>：<code>dom</code>  交互时间</li> <li><code>domainLookupEnd</code>：域查找结束时间</li> <li><code>domainLookupStart</code>：域查找开始时间</li> <li><code>duration</code>：事件耗时</li> <li><code>encodedBodySize</code>：编码主体大小</li> <li><code>entryType</code>：资源输入类型</li> <li><code>fetchStart</code>：获取资源开始时间</li> <li><code>initiatorType</code>：发起人类型</li> <li><code>loadEventEnd</code>：加载事件结束时间</li> <li><code>loadEventStart</code>：加载事件开始时间</li> <li><code>name</code>：这里一般就是当前请求的  <code>url</code>  的地址</li> <li><code>nextHopProtocol</code>：下一个跳转协议</li> <li><code>redirectCount</code>：重定向次数</li> <li><code>redirectEnd</code>：重定向开始时间，如果没有重定向，值为 0</li> <li><code>redirectStart</code>：重定向结束时间，如果没有重定向，值为 0</li> <li><code>requestStart</code>：请求开始时间</li> <li><code>responseEnd</code>：响应结束时间</li> <li><code>responseStart</code>：响应开始时间</li> <li><code>secureConnectionStart</code>：安全连接开始时间</li> <li><code>serverTiming</code>：服务器时间</li> <li><code>startTime</code>：开始时间</li> <li><code>transferSize</code>：传递大小</li> <li><code>type</code>：该事件的类型</li> <li><code>unloadEventEnd</code>：卸载事件结束时间</li> <li><code>unloadEventStart</code>：卸载事件开始时间</li> <li><code>workerStart</code>：<code>worker</code>  开始时间</li></ul> <hr> <h3 id="performance-mark-name"><a href="#performance-mark-name" class="header-anchor">#</a> <code>Performance.mark(name)</code></h3> <p>根据给出  <code>name</code>  值，在浏览器的性能输入缓冲区中创建一个相关的时间戳</p> <hr> <h3 id="performance-measure-name-startmark-endmark"><a href="#performance-measure-name-startmark-endmark" class="header-anchor">#</a> <code>Performance.measure(name, startMark, endMark)</code></h3> <p>这里接收三个参数：</p> <ul><li><code>name</code>：测量的名字</li> <li><code>startMark</code>：测量的开始标志名字（也可以是  <code>PerformanceTiming</code>  属性的名称）</li> <li><code>endMark</code>：测量的结束标志名字（也可以是  <code>PerformanceTiming</code>  属性的名称）</li></ul> <hr> <h3 id="performance-getentriesbyname-name-type"><a href="#performance-getentriesbyname-name-type" class="header-anchor">#</a> <code>Performance.getEntriesByName(name, type)</code></h3> <p>这里接收两个参数：</p> <ul><li><code>name</code>：测量的名字</li> <li><code>type</code>：测量的类型（<code>frame, navigation</code> 、<code>resource</code> 、 <code>mark</code> 、<code>measure</code> 、<code>paint</code>）</li></ul> <hr> <h3 id="performance-getentriesbytype-type"><a href="#performance-getentriesbytype-type" class="header-anchor">#</a> <code>Performance.getEntriesByType(type)</code></h3> <p>接收一个参数，<code>type</code>  同上面  <code>Performance.getEntriesByName(name, type)</code>  的  <code>type</code></p> <hr> <h3 id="performance-now"><a href="#performance-now" class="header-anchor">#</a> <code>Performance.now()</code></h3> <p>返回一个表示从性能测量时刻开始经过的毫秒数</p> <hr> <h3 id="performance-setresourcetimingbuffersize-maxsize"><a href="#performance-setresourcetimingbuffersize-maxsize" class="header-anchor">#</a> <code>Performance.setResourceTimingBufferSize(maxSize)</code></h3> <p>设置浏览器应在其性能条目缓冲区中保存的最大性能条目对象数</p> <hr> <h3 id="performance-tojson"><a href="#performance-tojson" class="header-anchor">#</a> <code>Performance.toJSON()</code></h3> <p>返回  <code>Performance</code>  对象的  <code>JSON</code>  对象</p> <hr> <p><code>Performance API</code>  的介绍也差不多了，浏览器的兼容性也是很不错的：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da52eb73e9c64d9b8994a9329dd82e35~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>基本上在我们项目当中去做性能检测是没有问题的，毕竟我们是肯定不能把有关性能检测的代码打包到项目当中</p> <h3 id="performance-api-的简单使用"><a href="#performance-api-的简单使用" class="header-anchor">#</a> <code>Performance API 的简单使用</code></h3> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5c820b7ff7c4a6593e860934f4aad04~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>这是我写的一个小 demo ，大致的意思：</p> <p>就是我们在定时器执行前，添加了个标记  <code>measure-start</code>；</p> <p>在定时器执行后，又添加了个标记  <code>measure-end</code>；</p> <p>测量一下两个标记之间的开始时间和持续时间  <code>measure-list</code>；</p> <p>最后清除所有  <code>marks</code>  的标志位和  <code>measures</code>  的标志位；</p> <p>从这个小 demo 我们就能看出来它的实用性和方便性，从这里我们就可以看出来，<code>Performance API</code>  可以横跨很多个方法，去检测它的调用时间，而  <code>Performance 工具</code>  就没有办法做到这一点</p> <p>这就是我所说的相辅相成的关键点所在</p></div> <ul class="post-copyright" data-v-048450f4 data-v-03440d80><li class="post-copyright-author" data-v-048450f4><b data-v-048450f4>本文作者：</b>
    新宿猫
  </li> <li class="post-copyright-link" data-v-048450f4><b data-v-048450f4>本文链接：</b> <a href="" data-v-048450f4></a></li> <li class="post-copyright-license" data-v-048450f4><b data-v-048450f4>版权声明：</b> <div data-v-048450f4>
      本博客所有文章除特别声明外，均默认采用<span class="license" data-v-048450f4>CC BY-NC-SA 4.0</span>许可协议
    </div></li></ul></div> <div class="pagination-wrapper" data-v-4cb2258c data-v-03440d80><div class="pagination-pre" style="display:none;" data-v-4cb2258c><a href="/frontend/performance_tool.html" aria-current="page" class="router-link-exact-active router-link-active" data-v-4cb2258c><i aria-hidden="true" class="fa fa-chevron-left" data-v-4cb2258c></i> <span data-v-4cb2258c></span></a></div> <div class="pagination-next" style="display:none;" data-v-4cb2258c><a href="/frontend/performance_tool.html" aria-current="page" class="router-link-exact-active router-link-active" data-v-4cb2258c><span data-v-4cb2258c></span> <i aria-hidden="true" class="fa fa-chevron-right" data-v-4cb2258c></i></a></div></div> <!----></div> <div class="image-box" data-v-03440d80><div class="image-modal close"><div class="image-header"><button class="image-close"><i aria-hidden="true" class="fa fa-times"></i></button></div> <div class="image-container"><img src="" alt="Loading" draggable="false" class="image-zoom"></div> <div class="image-controller"><button class="image-enlarge"><i aria-hidden="true" class="fa fa-search-plus"></i></button> <button class="image-shrink"><i aria-hidden="true" class="fa fa-search-minus"></i></button></div></div></div></div> <div class="blog-footer" data-v-0f954ca7 data-v-273099e5><!----> <p data-v-0f954ca7>Copyright © -Present 新宿猫 | Theme By Vivek</p> <div class="support" data-v-0f954ca7></div></div></section></div></div><div class="global-ui"><div class="blog-controller" data-v-0b226314><div class="controller-menu" data-v-0b226314><button class="show-menu controller-item" data-v-0b226314><div class="item-dot" data-v-0b226314></div></button> <button class="show-list controller-item" data-v-0b226314><i aria-hidden="true" class="fa fa-list-ul" data-v-0b226314></i></button> <button class="back-to-top controller-item" data-v-0b226314><i aria-hidden="true" class="fa fa-chevron-up" data-v-0b226314></i></button> <button class="show-sidebar controller-item" data-v-0b226314><i aria-hidden="true" class="fa fa-columns" data-v-0b226314></i></button></div></div></div></div>
    <script src="/assets/js/app.654767d1.js" defer></script><script src="/assets/js/2.b710c5fc.js" defer></script><script src="/assets/js/5.8b669e08.js" defer></script><script src="/assets/js/19.c440fbe3.js" defer></script><script src="/assets/js/4.ad11ada8.js" defer></script><script src="/assets/js/6.12f579ad.js" defer></script>
  </body>
</html>
